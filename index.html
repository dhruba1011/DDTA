<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Algorithm & Flowchart Tutorial</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header><h1>Algorithm and Flowchart Tutorial</h1></header>
  <nav>
    <a href="index.html">Home</a>
    <a href="algorithm.html">Algorithm</a>
    <a href="flowchart.html">Flowchart</a>
    <a href="examples.html">Examples</a>
  </nav>
  <main>

 <h1>1. Algorithms</h1>

  <div class="section">
    <h2>Introduction</h2>
    <p><strong>Understanding Algorithms:</strong> An algorithm is a well-defined, step-by-step procedure designed to solve a specific problem or perform a particular task. It acts as the blueprint for solving computational challenges efficiently, whether it involves sorting data, searching for information, or optimizing results. Algorithms are the foundation of all computer programs and software applications, helping systems perform operations in a logical and structured way. They are usually evaluated based on their correctness, efficiency (in terms of time and space), and clarity, making it essential for programmers to select or design the right algorithm for each situation.</p>

    <p><strong>Introduction to Flowcharts:</strong> A flowchart is a visual representation of an algorithm or process, using standardized symbols to denote actions, decisions, inputs, and outputs. Flowcharts help programmers and developers understand the logical flow of a problem and plan solutions before writing actual code. By clearly mapping out each step and the decision paths, flowcharts make complex algorithms easier to visualize, debug, and communicate with others. Whether you are designing a simple program or modeling a real-world process, flowcharts serve as a powerful tool for structured thinking and effective problem-solving.</p>
  </div>

  <div class="section">
    <h2>Types of Algorithms</h2>

    <p><strong>Sorting Algorithms:</strong> Arrange data in a specific order.<br>
    <span class="examples">Examples: Bubble Sort, Merge Sort, Quick Sort, Heap Sort.</span></p>

    <p><strong>Searching Algorithms:</strong> Find specific elements in a dataset.<br>
    <span class="examples">Examples: Binary Search, Linear Search, Depth-First Search (DFS), Breadth-First Search (BFS).</span></p>

    <p><strong>Dynamic Programming:</strong> Breaks problems into smaller overlapping subproblems.<br>
    <span class="examples">Examples: Fibonacci Sequence, Knapsack Problem, Longest Common Subsequence.</span></p>

    <p><strong>Greedy Algorithms:</strong> Make the best choice at each step.<br>
    <span class="examples">Examples: Dijkstra’s Algorithm, Prim’s Algorithm, Huffman Encoding.</span></p>

    <p><strong>Divide and Conquer:</strong> Divide a problem into smaller subproblems, solve them, and combine results.<br>
    <span class="examples">Examples: Merge Sort, Quick Sort, Binary Search.</span></p>

    <p><strong>Backtracking:</strong> Explore all possibilities to solve a problem.<br>
    <span class="examples">Examples: Sudoku Solver, N-Queens Problem, Maze Solver.</span></p>
  </div>

  <div class="section">
    <h2>Algorithm Complexity</h2>
    <p><strong>Time Complexity:</strong> Measures how the runtime of an algorithm grows with input size.<br>
    Common classes: O(1), O(log n), O(n), O(n log n), O(n²), etc.</p>
  </div>

    
  </main>
  <footer>&copy; 2025 Tutorial Hub</footer>
</body>
</html>
